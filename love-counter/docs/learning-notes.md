# Learning Notes

This file contains what I learned through the project, organized by date.

---

## 📚 目次

- [2025/12/6 - LINEチャネル, プロバイダー, Messaging API, 複数ボット管理, 機能分岐設計, **Vercelビルドエラー解決**](#20251206---lineチャネルとボットの関係)
- [2025/12/5 - SVG, ベクター画像, path, circle, text, viewBox, xmlns, 名前空間, グラデーション, 描画順序, Q (Quadratic curve), 制御点](#20251205---svgとcssの違い)
- [2025/12/4 - innerHTML, disabled, Math.random(), Math.floor(), setTimeout(), 配列, 関数の引数, path順序, Z (Close path), SVG重なり順, **左右対称ロジック**, **曲線の滑らかさ調整**](#20251204---javascript基礎)

---
１２・６
1205_channel


## 2025/12/6 - LINEチャネルとボットの関係

### プロバイダーとチャネルの構造

#### 基本概念

**プロバイダー** = 開発者（または企業）を識別するグループ
**チャネル** = 1つのLINEボット

```
あなた（開発者）
    │
    └── プロバイダー（例: "Love Counter App"）
            │
            ├── チャネル1: 「私のこと好き？ボット」
            ├── チャネル2: 「TODOリマインダーボット」
            └── チャネル3: 「天気予報ボット」
```

#### 重要なポイント

1. **1つのプロバイダーで複数のチャネル（ボット）を作成できる**
2. **各チャネルは完全に独立している**
   - 別々のチャネルID
   - 別々のアクセストークン
   - 別々のWebhook URL
   - 別々の友達追加QRコード

3. **プロジェクトごとにチャネルを分けられる**
   - love-counter用のボット
   - TODO管理用のボット
   - 天気予報用のボット
   など、プロジェクトごとに独立したボットを運用できる

---

### 2つのアーキテクチャパターン

#### パターン1: 複数のボット（チャネル）で役割分担

```
会社: 株式会社ABC
  │
  ├── 公式LINE①: 「ABC商品情報ボット」
  │   └── チャネル1（独立したLINEアカウント）
  │       - QRコード①で友達追加
  │       - 商品カタログ、在庫確認
  │
  ├── 公式LINE②: 「ABC予約受付ボット」
  │   └── チャネル2（独立したLINEアカウント）
  │       - QRコード②で友達追加
  │       - 予約、空き状況確認
  │
  └── 公式LINE③: 「ABCカスタマーサポート」
      └── チャネル3（独立したLINEアカウント）
          - QRコード③で友達追加
          - 問い合わせ対応、FAQ
```

**メリット:**
- ✅ 各ボットが完全に独立
- ✅ 1つのボットが壊れても他に影響しない
- ✅ セキュリティ（アクセストークンが別々）

**デメリット:**
- ❌ ユーザーが複数のボットを友達追加する手間
- ❌ 管理が複雑（複数のコードベース）

---

#### パターン2: 1つのボット内で複数機能を実装（推奨）

```
会社: 株式会社ABC
  │
  └── 公式LINE: 「ABC公式アカウント」
      └── チャネル1つ（1つのLINEアカウント）
          │
          ├── 機能A: 商品情報 ─┐
          ├── 機能B: 予約受付  ├─ コード内で分岐処理
          └── 機能C: サポート ─┘
```

**実装例:**

```javascript
// api/webhook.js（1つのボット内で機能を分岐）

async function handleEvent(event) {
  if (event.type === 'message' && event.message.type === 'text') {
    const userMessage = event.message.text;

    // ユーザーのメッセージ内容で機能を振り分け
    if (userMessage === 'メニュー') {
      // メニューを表示
      return replyMenu(event.replyToken);

    } else if (userMessage.startsWith('予約')) {
      // 予約機能
      return handleReservation(event);

    } else if (userMessage.startsWith('商品')) {
      // 商品情報機能
      return handleProductInfo(event);

    } else if (userMessage.startsWith('問い合わせ')) {
      // サポート機能
      return handleSupport(event);
    }
  }
}

// メニュー表示
async function replyMenu(replyToken) {
  const menu = {
    type: 'text',
    text: `【メニュー】
1️⃣ 商品情報
2️⃣ 予約受付
3️⃣ お問い合わせ

番号を送信してください。`
  };
  return client.replyMessage(replyToken, menu);
}
```

**メリット:**
- ✅ ユーザーは1つのボットを友達追加するだけ
- ✅ 管理が楽（1つのチャネル、1つのコードベース）
- ✅ すべての機能を1箇所で把握できる
- ✅ ユーザーデータが1箇所に集まる（分析しやすい）

**デメリット:**
- ❌ コードが複雑になる可能性（関数を整理すれば解決可能）

---

### 実際のビジネス事例

#### 大企業の例

**スターバックス**
- **1つの公式LINE**で全機能を統合
- メニュー: クーポン、店舗検索、新商品情報など

**ユニクロ**
- **1つの公式LINE**で全機能を統合
- メニュー: 商品検索、在庫確認、セール情報など

#### なぜ1つにまとめる？

1. **ユーザー体験の向上**
   - 友達追加が1回で済む
   - 複数のボットを管理する手間がない

2. **データ統合**
   - ユーザーの行動データが1箇所に集まる
   - マーケティング分析がしやすい

3. **運用コスト削減**
   - 管理が楽
   - メンテナンスしやすい

---

### 比較表

| 項目 | 複数ボット方式 | 1つのボット方式 |
|------|--------------|----------------|
| **公式LINEアカウント数** | 複数（役割ごと） | 1つ |
| **友達追加** | 各ボットごと | 1回だけ |
| **管理** | 分散（複雑） | 集中（シンプル） |
| **コード** | それぞれ独立 | 1つのコードで分岐 |
| **データ分析** | 分散している | 一元化 |
| **ユーザー体験** | 複数追加の手間 | シンプル |
| **おすすめ度** | △（特殊な場合のみ） | ⭕（一般的） |

---

### love-counterプロジェクトへの適用

#### 現在の設計
```
チャネル1: 「私のこと好き？ボット」
  - 機能: メッセージ送信のみ
```

#### 将来的に拡張する場合（1つのボット内で）
```
チャネル1: 「私のこと好き？ボット」
  ├── 機能A: メッセージ送信
  ├── 機能B: 記念日リマインダー
  ├── 機能C: 写真共有
  └── 機能D: デートプラン提案
```

すべて1つのチャネル内でコードで機能を分けます。

---

### 料金について

**LINE Messaging APIは無料で複数のチャネルを作成できる**

- 無料プラン: 月200通まで（ブロードキャストメッセージ）
- Push API（今回使用）: 無制限（ユーザーへの個別送信）

新しいプロジェクトを作るたびに、新しいチャネル（ボット）を無料で追加できる。

---

### まとめ（2025/12/6）

1. **プロバイダー** = 開発者のグループ（1つ持てばOK）
2. **チャネル** = 1つのLINEボット
3. **1つのプロバイダーで複数のチャネル作成可能**
4. **プロジェクトごとにチャネルを分けられる**
5. **推奨**: 1つのボット内で機能を分岐させる方式
   - ユーザー体験が良い
   - 管理が楽
   - データ分析しやすい
6. **各チャネルは完全に独立**（ID、トークン、Webhook URLが別々）

---

### ❌ エラー解決: Vercelビルドエラー（循環参照）

#### 発生したエラー

**状況:**
GitHubにプッシュ後、Vercelの自動デプロイが失敗

**エラーメッセージ:**
```
Build Failed
The deployment failed to build.
Running "vercel build"
```

**ビルドログ:**
```
Installing dependencies...
npm warn deprecated ...（多数の警告）
```

ビルドプロセスが`vercel build`を実行しようとして、循環参照で失敗。

---

#### 原因

**package.jsonのbuildスクリプトが問題:**

```json
// ❌ 問題のあるコード
{
  "scripts": {
    "build": "vercel build"  // ← これが循環参照を起こす
  }
}
```

**なぜ問題か？**
1. Vercelは自動的に`npm run build`を実行する
2. `build`スクリプトが`vercel build`を実行
3. `vercel build`が`npm run build`を実行
4. → **無限ループ（循環参照）** で失敗

**そもそも、このプロジェクトは静的サイト（HTML, CSS, JS）なので、ビルドプロセスは不要！**

---

#### 解決方法

**package.jsonからbuildスクリプトを削除:**

```json
// ✅ 修正後
{
  "scripts": {
    "dev": "vercel dev",
    "test": "echo \"Error: no test specified\" && exit 1"
    // buildスクリプトを削除
  }
}
```

**修正コマンド:**
```bash
# 修正をコミット
git add love-counter/package.json
git commit -m "fix: package.jsonのbuildスクリプトを削除"

# mainブランチにプッシュ
git checkout main
git merge dev
git push origin main
```

---

#### Vercelの設定確認

**Root Directory設定が重要:**

1. Vercel Dashboard → プロジェクト → Settings → General
2. **Root Directory**: `love-counter` に設定

これがないと、Vercelがpackage.jsonを見つけられない。

---

#### 学んだこと

1. **静的サイトにはビルドスクリプトは不要**
   - HTML, CSS, JSのみ = ビルド不要
   - React, Next.jsなど = ビルド必要

2. **package.jsonのscriptsの役割**
   - `build`: Vercelが自動的に実行
   - `dev`: ローカル開発用
   - 不要なスクリプトは削除すべき

3. **循環参照の怖さ**
   - `vercel build` → `npm run build` → `vercel build` → ループ
   - 無限ループでビルドが止まらない

4. **Vercelのデプロイフロー**
   ```
   GitHub Push
     ↓
   Vercel自動デプロイ開始
     ↓
   npm install（依存パッケージインストール）
     ↓
   npm run build（buildスクリプト実行）← ここでエラー
     ↓
   デプロイ完了
   ```

5. **Root Directoryの重要性**
   - モノレポ構成の場合は必須設定
   - `love-counter/` にpackage.jsonがあるので設定が必要

---

#### トラブルシューティング手順

**エラーが出たら：**

1. **ビルドログを全て確認**
   - Vercel Dashboard → Deployments → 失敗したデプロイ
   - Build Logsタブ → 一番下までスクロール

2. **エラーメッセージで検索**
   - `npm ERR!` で始まる行を探す
   - `Error:` で始まる行を探す

3. **package.jsonを確認**
   - buildスクリプトが適切か
   - 依存パッケージが正しいか

4. **Vercelの設定を確認**
   - Root Directory
   - Build Command
   - Output Directory

---

#### まとめ（エラー解決）

| 項目 | 問題 | 解決 |
|------|------|------|
| **エラー** | Vercelビルド失敗 | buildスクリプト削除 |
| **原因** | 循環参照 | 静的サイトなのでビルド不要 |
| **学び** | package.jsonのscripts理解 | 不要なスクリプトは削除 |
| **設定** | Root Directory未設定 | `love-counter`に設定 |

---

## 2025/12/5 - SVG座標調整方法
<!-- リンゴの根本の軸（下向き曲線） -->
  <path d="M 44,29 Q 50,33 55,28" ... />

  構成：
  - 始点: M 44,29 (左端)
  - 制御点: Q 50,33 (カーブの深さ)
  - 終点: 55,28 (右端)

  下に下げる方法

  すべてのy座標を大きくすることで下に移動します。

  例: 2ピクセル下げる場合
  <!-- 調整前 -->
  M 44,29 Q 50,33 55,28

  <!-- 調整後（+2ピクセル） -->
  M 44,31 Q 50,35 55,30
     ↑+2   ↑+2   ↑+2

  例: 3ピクセル下げる場合
  M 44,32 Q 50,36 55,31
     ↑+3   ↑+3   ↑+3
<br>
## 2025/12/5 - SVGとCSSの違い

### SVGとは？

**SVG（Scalable Vector Graphics）** = 拡大縮小できるベクター画像

画像を「数式や座標」で描く技術。どんなサイズでもきれいに表示できる。

### 普通の画像との違い

```
PNG/JPG（ラスター画像）
├─ ピクセル（点）の集まり
└─ 拡大すると → ぼやける、ギザギザ

SVG（ベクター画像）
├─ 数式で描かれた図形
└─ 拡大しても → どんなサイズでもきれい✨
```

---

### CSSで図形を描く vs SVG

#### 1. CSSで図形を描く

```css
/* 丸を作る */
.circle {
  width: 100px;
  height: 100px;
  background: red;
  border-radius: 50%; /* これで丸くなる */
}

/* ハート（複雑...無理やり感がある） */
.heart {
  width: 100px;
  height: 90px;
  background: red;
  transform: rotate(-45deg);
}
.heart::before,
.heart::after {
  content: "";
  width: 100px;
  height: 90px;
  background: red;
  border-radius: 50%;
  position: absolute;
}
```

**CSSの特徴：**
- ✅ 簡単な図形（丸、四角）は楽
- ❌ 複雑な図形は難しい・無理やり感
- ❌ 細かいコントロールが難しい

---

#### 2. SVGで図形を描く

```html
<!-- 丸を作る -->
<svg width="100" height="100">
  <circle cx="50" cy="50" r="40" fill="red" />
</svg>

<!-- リンゴを作る（複雑な形も自由に描ける） -->
<svg width="100" height="100" viewBox="0 0 100 100">
  <!-- リンゴの本体 -->
  <path d="M50,20 C30,20 20,35 20,50 C20,70 35,85 50,90 C65,85 80,70 80,50 C80,35 70,20 50,20 Z" fill="red"/>
  <!-- 茎 -->
  <path d="M50,10 L50,20" stroke="brown" stroke-width="2"/>
  <!-- 葉っぱ -->
  <path d="M52,12 Q58,8 60,12 Q58,15 52,12" fill="green"/>
</svg>
```

**SVGの特徴：**
- ✅ 複雑な図形も自由に描ける
- ✅ 細かいコントロールができる
- ✅ アニメーションしやすい
- ✅ 拡大縮小してもきれい
- ❌ コードが長くなることがある

---

### 比較表

| | **CSS** | **SVG** |
|---|---|---|
| **簡単な図形** | ◎ とても簡単 | ○ 普通 |
| **複雑な図形** | △ 難しい | ◎ 得意 |
| **アニメーション** | ○ できる | ◎ 細かく制御できる |
| **拡大縮小** | ○ できる | ◎ どんなサイズでもきれい |
| **コードの量** | 少ない | 多くなることも |
| **使いどころ** | 単純な装飾 | イラスト、ロゴ、アイコン |

---

### SVGの基本要素

```html
<svg width="200" height="200" viewBox="0 0 200 200">
  <!-- 円 -->
  <circle cx="100" cy="100" r="50" fill="blue" />

  <!-- 四角 -->
  <rect x="50" y="50" width="100" height="80" fill="green" />

  <!-- 線 -->
  <line x1="0" y1="0" x2="200" y2="200" stroke="black" stroke-width="2" />

  <!-- 自由な形（パス） -->
  <path d="M 10,30 L 50,90 L 90,30" stroke="red" fill="none" stroke-width="3" />
</svg>
```

**よく使う要素：**
- `<circle>` = 円
- `<rect>` = 四角
- `<line>` = 線
- `<path>` = 自由な形（一番よく使う）
- `<ellipse>` = 楕円
- `<polygon>` = 多角形

---

### 結論

- **簡単な図形（丸、四角）** → **CSSが楽** 🟢
- **複雑な図形（リンゴ、ハート、イラスト）** → **SVGが得意** 🍎

**このプロジェクトでは：**
リンゴマークのボタンを作るので、**SVGを使う** のが最適！

---

### SVGの構造（重要）

#### viewBoxと座標系
```html
<svg viewBox="0 0 100 100">
  ↑ 左上(0,0)から右下(100,100)の空間
```

- x軸：右に行くほど大きい
- y軸：下に行くほど大きい

#### path要素のコマンド

| コマンド | 意味 | 例 |
|---|---|---|
| M x,y | Move（移動） | `M 50,25` |
| L x,y | Line（直線） | `L 50,80` |
| C x1,y1 x2,y2 x,y | Cubic curve（3次曲線） | `C 30,25 20,35 20,50` |
| Q x1,y1 x,y | Quadratic curve（2次曲線） | `Q 45,8 40,10` |
| Z | Close path（閉じる） | `Z` |

**Qコマンドの詳しい使い方は → [SVG調整ガイド.md](SVG調整ガイド.md) 参照**

---

#### リンゴボタンの構成

```html
<svg viewBox="0 0 100 100">
  <!-- 1. 葉っぱ（path） -->
  <path d="M 48,15 Q 45,8 40,10..." fill="#8bc34a" />

  <!-- 2. 茎（path） -->
  <path d="M 48,15 L 50,25" stroke="#8d6e63" stroke-width="2" />

  <!-- 3. リンゴ本体（path） -->
  <path d="M 50,25 C 30,25..." fill="#f48fb1" />

  <!-- 4. ハイライト（ellipse） -->
  <ellipse cx="38" cy="40" rx="8" ry="12" fill="#ffc1e3" opacity="0.6" />

  <!-- 5. テキスト（text） -->
  <text x="50" y="58">YES</text>
</svg>
```

#### よく使う属性

- `fill` = 塗りつぶしの色
- `stroke` = 線の色
- `stroke-width` = 線の太さ
- `opacity` = 透明度（0〜1）
- `cx, cy` = 円の中心座標
- `rx, ry` = 楕円の半径

**詳しい調整方法は `SVG調整ガイド.md` を参照！**

---

### xmlns（名前空間）とは？

#### 基本
```html
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100">
     ↑ これが名前空間の宣言
```

**xmlns** = XML Namespace（エックスエムエル・ネームスペース）の略

#### 何のため？

「このタグはSVG用だよ」とブラウザに教えるため。

**例：同じ名前のタグ問題**
```html
<!-- HTMLの<a>タグ = リンク -->
<a href="...">クリック</a>

<!-- SVGの<a>タグ = 別の意味 -->
<svg>
  <a>...</a>
</svg>
```

同じ`<a>`でもHTMLとSVGで意味が違う！
→ 名前空間で区別する

#### URLだけど、アクセスしない

```
http://www.w3.org/2000/svg
↑ これはただの「識別子（名札）」
  実際にこのURLにアクセスするわけではない
```

**なぜURLっぽい？**
- 世界中で重複しないようにするため
- W3C（Web標準を作る組織）が管理している

#### 省略できる？

**HTML5に埋め込む場合：**
```html
<!DOCTYPE html>
<html>
<body>
  <!-- 省略してもOK -->
  <svg viewBox="0 0 100 100">
    <circle cx="50" cy="50" r="40" />
  </svg>
</body>
</html>
```

**でも書いておく方が安全** → 古いブラウザ対応

#### まとめ

- `xmlns="http://www.w3.org/2000/svg"` = SVGの名札
- タグの名前がHTMLと被っても区別できる
- HTML5では省略可能だけど、書いておく方が無難

#### 自分で書くときはどうする？

**答え：常に `xmlns="http://www.w3.org/2000/svg"` をそのまま使う**

```html
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100">
  <!-- いつもこの値 ↑ -->
</svg>
```

**理由：**
- これはSVG仕様で**決められた固定値**
- 自分で考える必要はない
- SVGを書くときは**常にこのURLを使う**

**他の名前空間の例：**
- SVG → `http://www.w3.org/2000/svg`（固定）
- MathML → `http://www.w3.org/1998/Math/MathML`（固定）
- XHTML → `http://www.w3.org/1999/xhtml`（固定）

→ **すべて決められた値なので、コピペでOK！**

---

### SVGの描画順序（重要！）

#### 発見
SVGは**上から順番に描画される** → 後に書いた要素が上に表示される（重なる）

#### 例：リンゴの軸は本体の後に書く

```html
<svg viewBox="0 0 100 100">
  <!-- ❌ 軸を先に書くと、リンゴ本体に隠れる -->
  <path d="M 45,28 Q 50,23 55,28" stroke="#8d6e63" />
  <path class="apple-body" d="M 50,25 C 30,25..." fill="#E89B9B" />

  <!-- ✅ リンゴ本体の後に軸を書く → 上に表示される -->
  <path class="apple-body" d="M 50,25 C 30,25..." fill="#E89B9B" />
  <path d="M 45,28 Q 50,23 55,28" stroke="#8d6e63" />
</svg>
```

#### 描画の順番（レイヤー構造）

```
下層（最初に描画）
├─ 1. リンゴ本体
├─ 2. ハイライト
├─ 3. 茎
├─ 4. 葉っぱ
└─ 5. テキスト
上層（最後に描画）← 一番上に表示される
```

**コードの順序 = 表示の重なり順**
- 最初に書いた要素 → 一番下
- 最後に書いた要素 → 一番上

#### CSSのz-indexとの違い

| | **CSS** | **SVG** |
|---|---|---|
| **重なり順の制御** | `z-index`プロパティ | コードの記述順 |
| **変更方法** | CSSで後から変更可能 | HTMLの順序を変える必要がある |

**まとめ：**
- SVGには`z-index`はない
- **書いた順番が重なり順**を決める
- 上に表示したい要素は**後に書く**

---

## 2025/12/4 - JavaScript基礎

### 1. innerHTMLで改行を有効にする

#### 問題
`textContent`を使うと、HTMLタグ（`<br>`など）が文字列としてそのまま表示されてしまう。

#### 解決方法
`innerHTML`を使うことで、HTMLタグを解釈して改行が有効になる。

```javascript
// ❌ 改行されない
mainButton.textContent = "私のこと思い出したら<br>このボタン押してね？";
// 表示: 私のこと思い出したら<br>このボタン押してね？

// ✅ 改行される
mainButton.innerHTML = "私のこと思い出したら<br>このボタン押してね？";
// 表示: 私のこと思い出したら
//      このボタン押してね？
```

#### 注意点
- ボタン要素で改行を有効にするには、CSSに`white-space: normal;`を追加する必要がある
- `innerHTML`はHTMLタグを解釈するので、ユーザー入力を直接入れる場合はセキュリティに注意

---

### 2. disabledプロパティでボタンを無効化

#### 概要
`disabled`プロパティを使うと、ボタンをクリックできなくする（無効化する）ことができる。

#### 使い方
```javascript
// ボタンを無効化
mainButton.disabled = true;

// ボタンを有効化
mainButton.disabled = false;
```

#### 実際の使用例
22回目のメッセージ表示時に、ボタンを2.5秒間無効化する：

```javascript
if (count % 22 === 0 && count !== 0) {
  // ボタンを一時的に無効化
  mainButton.disabled = true;
  mainButton.style.opacity = "0.5";        // 見た目を薄くする
  mainButton.style.cursor = "not-allowed"; // カーソルを変更

  // 2.5秒後にボタンを再び有効化
  setTimeout(function() {
    mainButton.disabled = false;
    mainButton.style.opacity = "1";
    mainButton.style.cursor = "pointer";
  }, 2500);
}
```

---

### 3. Math.random()でランダム表示 - なぜarrayを引数にするのか？

#### 関数の定義
```javascript
function getRandomIndex(array) {
  return Math.floor(Math.random() * array.length);
}
```

#### なぜarrayを引数にするのか？

**理由1: 関数の再利用性**

`array`を引数にすることで、**どんな配列でも**この関数を使えるようになる。

```javascript
// triggers1配列で使う
mainButton.innerHTML = triggers1[getRandomIndex(triggers1)];

// messages1配列で使う
message.innerHTML = messages1[getRandomIndex(messages1)];
```

もし引数を使わずに書くと...

```javascript
// ❌ triggers1専用の関数
function getRandomIndexForTriggers() {
  return Math.floor(Math.random() * triggers1.length);
}

// ❌ messages1専用の関数
function getRandomIndexForMessages() {
  return Math.floor(Math.random() * messages1.length);
}
```

同じようなコードを何度も書く必要がある！

**理由2: 配列の長さが変わっても対応できる**

`array.length`を使うことで、配列の要素数が変わっても自動的に対応できる。

```javascript
// messages1が26個でも50個でも100個でも動く
message.innerHTML = messages1[getRandomIndex(messages1)];
```

**理由3: テストしやすい**

引数を渡すことで、どんなデータでもテストできる。

```javascript
// テスト用の小さい配列で試せる
const testArray = ["A", "B", "C"];
console.log(getRandomIndex(testArray)); // 0, 1, 2 のどれか
```

#### Math.random()の仕組み

```javascript
Math.random()  // 0以上1未満のランダムな小数 (例: 0.7234)
Math.random() * array.length  // 配列の長さを掛ける (例: 0.7234 * 50 = 36.17)
Math.floor(...)  // 小数点以下を切り捨て (例: 36)
```

**例:** 配列が50個の場合
- `Math.random()`が0.7234だとすると
- `0.7234 * 50 = 36.17`
- `Math.floor(36.17) = 36`
- → `array[36]`が選ばれる

---

---

### 4. SVGパスの左右対称ロジック

#### 問題：りんごが左右対称にならない

SVGで図形を描くとき、左右対称にしたいのに歪んでしまうことがある。

#### 左右対称の基本ルール

**中心軸を決める** → りんごの場合は `x=50` を中心とする

```
左側     中心     右側
←─────  x=50  ─────→
```

#### 対称性のチェック方法

x=50 を中心として、左右の座標が対称かを確認：

```
左側のx座標: 30  → 対称な右側: 100 - 30 = 70 ✓
左側のx座標: 20  → 対称な右側: 100 - 20 = 80 ✓
左側のx座標: 45  → 対称な右側: 100 - 45 = 55 ✓
```

**公式：** `右側のx座標 = 100 - 左側のx座標`

#### 実際のパス例

❌ **非対称なパス（問題）**
```svg
M 50,25                    # 始点（中央）
C 30,25 20,35 20,50       # 左上 ✓
C 20,65 26,82 45,81       # 左下（終点 x=45）
C 46,81.5 54,81.5 55,81   # 底部（始点 x=55）
C 74,78 80,65 80,50       # ❌ 右下（制御点 74,78）
C 80,35 70,25 50,25 Z     # 右上 ✓
```

**問題点：**
- 左下の制御点: `(26, 82)`
- 右下の制御点: `(74, 78)` ← y座標が違う！（82 ≠ 78）
- これでは左右対称にならない

✅ **対称なパス（修正後）**
```svg
M 50,25                    # 始点（中央）
C 30,25 20,35 20,50       # 左上
C 20,65 26,82 45,81       # 左下（制御点 26,82）
C 46,81.5 54,81.5 55,81   # 底部
C 74,82 80,65 80,50       # ✓ 右下（制御点 74,82）← 左と同じy座標
C 80,35 70,25 50,25 Z     # 右上
```

**対称性の確認：**

| 部位 | 左側の制御点 | 右側の制御点 | 対称？ |
|------|-------------|-------------|--------|
| 上部 | (30, 25) | (70, 25) | ✓ |
| 中央 | (20, 50) | (80, 50) | ✓ |
| 下部 | (26, 82) | (74, 82) | ✓ |
| 終点 | (45, 81) | (55, 81) | ✓ |

#### まとめ：左右対称にする手順

1. **中心軸を決める**（例: x=50）
2. **左側のパスを描く**
3. **右側のx座標を計算**
   - `右側x = 100 - 左側x`
4. **y座標は左右同じにする**
5. **制御点も忘れずに対称にする**

---

### 5. SVG曲線の滑らかさを調整する方法

#### 曲線の形を決める要素

SVGの `C`（三次ベジェ曲線）コマンドは以下で構成される：

```svg
C x1,y1 x2,y2 x,y
  ↑制御点1 ↑制御点2 ↑終点
```

#### 制御点の役割

制御点は「曲線の引っ張る方向」を決める：

```
始点 ●─────→ 制御点1
             ↓
          カーブ
             ↓
         制御点2 ←─────● 終点
```

#### カーブの緩急を調整する方法

**1. 底部のカーブを緩くする**

制御点のy座標を下に移動すると、カーブが下に膨らんで緩やかになる：

```svg
# 急なカーブ（制御点が近い）
C 46,85.5 54,85.5 55,85

# 緩いカーブ（制御点を下に移動）
C 46,88 54,88 55,85
    ↑y座標を大きく → カーブが緩くなる
```

**2. 左右の丸みを調整する**

制御点を外側に移動すると、カーブが広がって緩やかになる：

```svg
# 急なカーブ（制御点が内側）
C 20,65 30,80 45,85

# 緩いカーブ（制御点を外側に移動）
C 20,65 25,82 45,85
        ↑x座標を小さく（外側）、y座標を大きく → カーブが広がる
```

**視覚的な理解：**

```
急なカーブ:
  ●────●  ← 制御点が内側
   \  /
    \/
    終点

緩いカーブ:
  ●────────●  ← 制御点が外側
   \      /
    \    /
     \  /
      \/
     終点
```

#### 実際の調整例

**りんごの左下の丸みを緩くする：**

```svg
# 調整前（カーブがきつい）
C 20,65 30,80 45,85

# 調整後（カーブが緩やか）
C 20,65 26,82 45,81
        ↑     ↑
    x座標を小さく（外側に）
         y座標を大きく（下に）
```

**りんごの底部を滑らかにする：**

```svg
# 調整前（尖っている）
C 50,87 50,87 55,85
  ↑ 制御点が同じ位置 → 急な角度

# 調整後（滑らか）
C 46,85.5 54,85.5 55,85
  ↑ 制御点を左右に広げる → 緩やかなカーブ
```

#### 調整のコツ

| やりたいこと | 調整方法 |
|------------|----------|
| カーブを緩くしたい | 制御点を離す（外側に移動） |
| カーブをきつくしたい | 制御点を近づける（内側に移動） |
| 下に膨らませたい | 制御点のy座標を大きくする |
| 上に膨らませたい | 制御点のy座標を小さくする |
| 尖った部分を滑らかに | 制御点を左右に広げる |

#### デバッグ方法

調整がうまくいかないときは：

1. **制御点を可視化する**
   ```svg
   <!-- デバッグ用：制御点を表示 -->
   <circle cx="26" cy="82" r="2" fill="red" />
   <circle cx="74" cy="82" r="2" fill="blue" />
   ```

2. **少しずつ調整する**
   - いきなり大きく変えず、2〜3ピクセルずつ変える
   - ブラウザで確認しながら調整

3. **対称性を保つ**
   - 左を変えたら、必ず右も同じように変える

---

### まとめ（2025/12/4）

1. **innerHTML** = HTMLタグを解釈して改行できる
2. **disabled** = ボタンを無効化/有効化できる
3. **引数を使う理由** = 同じ関数を色々な配列で再利用できるから便利！
4. **左右対称ロジック** = 中心軸から等距離、y座標も揃える
5. **曲線の調整** = 制御点の位置でカーブの形が変わる
